# McBopomofo Copilot Instructions

## What's the Project For

McBopomofo (小麥注音輸入法) is a Traditional Chinese input method engine (IME) for macOS. It allows users to input Traditional Chinese characters using the Bopomofo phonetic system (注音符號), which is the standard phonetic notation system used in Taiwan. 

The project is part of the OpenVanilla framework and provides:
- Smart phonetic-to-character conversion
- User-customizable phrase dictionaries
- Associated phrase suggestions
- Multi-candidate selection
- Support for custom user phrases and exclusions

## System Requirements

### Runtime Requirements
- macOS 10.15 (Catalina) or later

### Development Requirements
- macOS 14.7 or later
- Xcode 15.3 or later
- Python 3.9 (available through Xcode or homebrew)

## Build Process

The project uses Xcode as its primary build system:

1. **Open Project**: Open `McBopomofo.xcodeproj` in Xcode
2. **Select Target**: Choose "McBopomofoInstaller" target
3. **Build**: Build the project (⌘+B)
4. **Install**: Run the installer directly to install McBopomofo
5. **Reinstall**: For subsequent updates, repeat the process

### Important Notes
- macOS may limit the number of times an input method process can be killed in a single login session
- If installation issues occur after multiple installs, log out and log back in
- The installer automatically kills and restarts the input method process

## Project Components

### Architecture Overview
```
McBopomofo/
├── Source/                     # Main application source
│   ├── Engine/                # C++ core engine
│   │   ├── Mandarin/         # Bopomofo processing
│   │   ├── gramambular2/     # Text segmentation library
│   │   └── McBopomofoLM.*    # Language model
│   ├── InputState.swift       # State machine implementation
│   ├── InputMethodController.swift  # Main controller
│   └── Data/                 # Language model data files
├── McBopomofoTests/           # Test suite
└── Packages/                  # Swift Package dependencies
```

### Technology Stack
- **Swift**: UI layer, input method controller, state management
- **Objective-C++**: Bridge between Swift and C++ components
- **C++**: Core engine, language processing, data structures
- **Xcode**: Build system and development environment

### Framework Foundation
McBopomofo is built on Apple's native input method frameworks:

#### Cocoa Framework
- **UI Components**: Native macOS user interface elements
- **Event Handling**: Keyboard and mouse event processing
- **Window Management**: Candidate window and preference panels
- **Integration**: Seamless integration with macOS applications

#### Input Method Kit (IMK)
- **IMKInputController**: Base class for input method controllers
  - `McBopomofoInputMethodController` extends `IMKInputController`
  - Handles input events and text processing
  - Manages communication with client applications
- **IMKServer**: Input method server infrastructure
  - Manages input method instances
  - Handles system-level input method operations
- **IMKCandidateController**: Candidate selection interface
- **Protocol Compliance**: Implements IMK protocols for proper system integration

### Key Files
- `InputMethodController.swift`: Main input method logic
- `InputState.swift`: State machine implementation
- `Source/Engine/McBopomofoLM.h/cpp`: Language model management
- `Source/Engine/Mandarin/Mandarin.h/cpp`: Bopomofo processing
- `Source/Engine/gramambular2/`: Text segmentation algorithms

## Design of Input States

McBopomofo implements a finite state machine with multiple distinct states to handle various input scenarios. The state machine ensures predictable behavior and clear separation of concerns for different input modes.

### Core Input States

1. **Deactivated**: User hasn't activated McBopomofo
   - Used when input method is not the active input source
   - No composing buffer or UI elements visible

2. **Empty**: McBopomofo is active but no input yet, or user just committed text
   - Clean slate state after text commitment or initial activation
   - Ready to receive new input

3. **EmptyIgnoringPreviousState**: Special empty state that ignores previous context
   - Used in specific scenarios where previous state should be cleared

4. **Inputting**: User is typing Bopomofo keys; input buffer is visible
   - Contains composing buffer with underlined text
   - Cursor index tracking for editing
   - Optional tooltip for user guidance

5. **Committing**: Sending text to client applications
   - Transient state during text output
   - Contains the text being committed

6. **Marking**: User is selecting text in buffer to create custom phrase
   - Special selection mode for creating user-defined phrases
   - Validates selection length (2-8 characters)
   - Shows different underline styles for marked region

7. **ChoosingCandidate**: Candidate window is open for user selection
   - Displays multiple conversion options
   - Supports vertical/horizontal candidate layouts
   - Maintains original cursor position

### Extended States

The system includes additional specialized states:

- **SelectingFeature**: User accessing special features menu (Big5, numbers, dates)
- **SelectingDateMacro**: Date/time macro selection with live preview
- **ChineseNumber**: Chinese numeral conversion (lower/upper/Suzhou styles)
- **Big5**: Big5 encoding conversion for character codes
- **EnclosedNumber**: Circled/parenthesized number conversion
- **AssociatedPhrases**: Associated phrase suggestions based on context
- **AssociatedPhrasesPlain**: Plain Bopomofo mode associated phrases
- **SelectingDictionary**: Dictionary lookup mode selection
- **ShowingCharInfo**: Character information display (UTF-8, UTF-16, URL encoding, etc.)
- **CustomMenu**: Custom menu operations with user-defined entries

### State Properties
- **Immutable**: States are immutable objects; transitions create new state instances
- **One-way Data Flow**: UI and text output follow single data source (the current state)
- **Context-Specific Data**: Each state contains only relevant data for its purpose
- **Type Safety**: Swift's type system ensures only valid state transitions

### State Transition Diagram

```
                    ┌─────────────┐
                    │ Deactivated │
                    └──────┬──────┘
                           │ activate
                           ▼
    ┌─────────────────────────────────────────────────────────┐
    │                    Empty                                │
    └─────────────────────┬───────────────────────────────────┘
                          │ start typing
                          ▼
    ┌─────────────────────────────────────────────────────────┐
    │                  Inputting                              │◄─┐
    └─┬──────────┬──────────┬────────────┬─────────────────────┘  │
      │ commit   │ mark     │ space/     │ Esc                    │
      │          │ range    │ candidate  │                        │
      ▼          ▼          ▼            ▼                        │
 ┌──────────┐ ┌─────────┐ ┌──────────────┐ ┌──────────────────────┐│
 │Committing│ │ Marking │ │ ChoosingCand │ │  SelectingFeature    ││
 └─────┬────┘ └───┬─────┘ └───────┬──────┘ └─┬─┬─┬─┬─┬─────────────┘│
       │          │ Enter         │ select    │ │ │ │ │              │
       │          │               │           │ │ │ │ │              │
       ▼          ▼               ▼           │ │ │ │ │              │
    ┌─────┐   ┌─────────┐    ┌─────────┐     │ │ │ │ │              │
    │Empty│   │Inputting│    │Inputting│     │ │ │ │ │              │
    └─────┘   └─────────┘    └─────────┘     │ │ │ │ │              │
                                             │ │ │ │ │              │
      ┌──────────────────────────────────────┘ │ │ │ │              │
      │  ┌───────────────────────────────────────┘ │ │ │              │
      │  │  ┌──────────────────────────────────────┘ │ │              │
      │  │  │  ┌─────────────────────────────────────┘ │              │
      │  │  │  │  ┌──────────────────────────────────────┘              │
      ▼  ▼  ▼  ▼  ▼                                                     │
  ┌──────────┐ ┌────────────┐ ┌──────────┐ ┌─────────────┐              │
  │   Big5   │ │SelectDate  │ │ChineseNum│ │EnclosedNum  │──────────────┘
  └────┬─────┘ └─────┬──────┘ └────┬─────┘ └─────┬───────┘
       │ Esc         │ Esc          │ Esc         │ Esc
       ▼             ▼              ▼             ▼
    ┌─────────────────────────────────────────────┐
    │            Inputting                        │
    └─────────────────────────────────────────────┘
    
    Additional States (from ChoosingCandidate or Inputting):
    
    ChoosingCandidate ─────► AssociatedPhrases ─────► Inputting
                     │                          │
                     └─► SelectingDictionary ───┴─► ShowingCharInfo
                                               │
                                               └─► CustomMenu
```

### How Input States Are Used and Handled

#### State Management Pattern
The input method controller maintains a single current state and processes events through state-specific handlers:

```swift
// State transition example
func handleKeyEvent(event: NSEvent) -> InputState {
    switch currentState {
    case let inputting as InputState.Inputting:
        return handleInputtingState(inputting, event: event)
    case let choosing as InputState.ChoosingCandidate:
        return handleChoosingCandidateState(choosing, event: event)
    // ... handle other states
    }
}
```

#### State Transition Principles
1. **Single Responsibility**: Each state handles only its specific functionality
2. **Immutable Transitions**: States never modify themselves; they return new state instances
3. **Data Encapsulation**: State-specific data is only accessible within that state
4. **Event-Driven**: State changes occur in response to user input or system events

### Adding New Input States

To add a new input state to McBopomofo:

#### 1. Define the State Class
Create a new class inheriting from appropriate base class:

```swift
@objc(InputStateNewFeature)
class NewFeature: InputState {
    @objc private(set) var customData: String
    
    @objc init(customData: String) {
        self.customData = customData
        super.init()
    }
    
    override var description: String {
        "<InputState.NewFeature, customData:\(customData)>"
    }
}
```

#### 2. Implement Required Protocols
If the state shows candidates, implement `CandidateProvider`:

```swift
extension NewFeature: CandidateProvider {
    var candidateCount: Int { /* return count */ }
    func candidate(at index: Int) -> String { /* return candidate */ }
}
```

#### 3. Add State Handling in Controller
Update `InputMethodController.swift` to handle the new state:

```swift
func handleNewFeatureState(_ state: InputState.NewFeature, event: NSEvent) -> InputState {
    // Process events specific to this state
    // Return appropriate next state
}
```

#### 4. Define State Transitions
Add transition logic in existing states that can lead to your new state:

```swift
// In InputState.SelectingFeature, for example
featureList.append(("New Feature", { .NewFeature(customData: "initial") }))
```

#### 5. Update UI Components
Ensure candidate window, tooltip display, and composing buffer handle the new state appropriately.

#### 6. Add Tests
Create comprehensive tests for the new state:
- State creation and data validation
- Event handling and state transitions  
- UI component integration
- Edge cases and error conditions

#### Best Practices for New States
- **Keep states focused**: Each state should have a single, clear purpose
- **Minimize data**: Only store data that's essential for the state's function
- **Clear transitions**: Document how to enter and exit the state
- **Consistent naming**: Follow existing naming patterns (`InputState[Purpose]`)
- **Proper cleanup**: Ensure resources are properly managed when transitioning away

## Design of Mandarin Package

The Mandarin package handles Bopomofo phonetic input processing and conversion.

### Core Classes

#### BopomofoSyllable (BPMF)
- **Purpose**: Represents a complete Bopomofo syllable
- **Storage**: 16-bit integer with bit masks for components
- **Components**: Consonant, Middle Vowel, Vowel, Tone Marker
- **Features**:
  - Conversion to/from Hanyu Pinyin
  - Composed string representation
  - Component validation and extraction
  - Overlap detection between syllables

#### BopomofoKeyboardLayout
- **Purpose**: Maps keyboard keys to Bopomofo components
- **Key Functions**:
  - `syllableFromKeySequence()`: Converts key sequence to syllable
  - `keySequenceFromSyllable()`: Converts syllable back to keys
- **Layout Support**: Different keyboard layouts for Bopomofo input
- **Validation**: Ensures valid key combinations (e.g., J/Q/X require I or UE vowels)

#### BopomofoReadingBuffer
- **Purpose**: Manages user input during syllable composition
- **Features**:
  - Key combination and validation
  - Pinyin mode support
  - Buffer clearing and state management
  - Integration with keyboard layouts

### Key Algorithms

#### Syllable Construction
1. Process each key in input sequence
2. Check for valid key combinations
3. Handle special cases (J/Q/X with I/UE vowels)
4. Apply tone markers correctly
5. Validate final syllable composition

#### Component Mapping
- Bit-masked representation for efficient storage
- Separate masks for consonants, vowels, and tones
- Support for multiple components per key

## Keyboard Layouts

McBopomofo supports multiple Bopomofo keyboard layouts to accommodate different user preferences and typing habits:

### Standard Layout
- **Description**: Traditional Bopomofo layout used in Taiwan
- **Characteristics**: Direct mapping of Bopomofo symbols to QWERTY keys
- **Usage**: Most common layout for Bopomofo input
- **Implementation**: `BopomofoKeyboardLayout::StandardLayout()`

### ETen Layout
- **Description**: ETen Traditional layout
- **Characteristics**: Alternative key mapping optimized for certain typing patterns
- **Usage**: Popular among users familiar with ETen input systems
- **Implementation**: `BopomofoKeyboardLayout::ETenLayout()`

### Hsu Layout (許氏鍵盤)
- **Description**: Hsu keyboard layout designed by Hsu Lian-chin
- **Characteristics**: 
  - Optimized for faster typing with fewer keystrokes
  - Special heuristics for vowel combinations
  - Automatic correction rules (e.g., GI/GUE → JI/JUE)
- **Usage**: Preferred by advanced users for speed typing
- **Implementation**: `BopomofoKeyboardLayout::HsuLayout()`

### ETen26 Layout
- **Description**: ETen 26-key layout variant
- **Characteristics**: Extended ETen layout with additional key combinations
- **Usage**: Enhanced version of ETen layout
- **Implementation**: `BopomofoKeyboardLayout::ETen26Layout()`

### IBM Layout
- **Description**: IBM-compatible Bopomofo layout
- **Characteristics**: 
  - Designed for IBM-style keyboard mapping conventions
  - Compatible with legacy IBM input systems
  - Optimized for business/enterprise environments
- **Usage**: Users familiar with IBM input method systems
- **Implementation**: `BopomofoKeyboardLayout::IBMLayout()`

### Hanyu Pinyin Layout
- **Description**: Hanyu Pinyin (漢語拼音) romanization input layout
- **Characteristics**: 
  - Uses Latin alphabet (a-z) for phonetic input
  - Supports tone markers (2, 3, 4, 5 for tones, tone 1 is unmarked)
  - Enables direct Pinyin-to-Bopomofo conversion
  - Special pinyin_mode in `BopomofoReadingBuffer` handles Latin input
- **Usage**: Users familiar with Mainland China's Pinyin system
- **Implementation**: `BopomofoKeyboardLayout::HanyuPinyinLayout()`
- **Technical Notes**:
  - Automatically converts Pinyin sequences to Bopomofo syllables
  - Uses `BPMF::FromHanyuPinyin()` for conversion
  - Handles tone marker validation (only allows 2-5 after syllable)

### Layout Architecture
- **Key-to-Component Mapping**: Each layout defines mappings from keyboard keys to Bopomofo components
- **Syllable Construction**: Layouts handle complex rules for syllable formation
- **Special Rules**: Each layout can implement specific typing optimizations and corrections
- **Runtime Switching**: Users can switch between layouts in preferences

### Creating New Keyboard Layouts

To add a new keyboard layout to McBopomofo:

#### 1. Define Key-to-Component Mapping
Create a `BopomofoKeyToComponentMap` that maps keyboard keys to Bopomofo components:

```cpp
// Example: Custom layout mapping
BopomofoKeyToComponentMap customMapping = {
    {'q', {BPMF::Q}},           // Single component
    {'w', {BPMF::W, BPMF::E}},  // Multiple components (disambiguation)
    {'1', {BPMF::Tone1}},       // Tone markers
    // ... continue for all keys
};
```

#### 2. Create Layout Factory Method
Add a static factory method in `BopomofoKeyboardLayout` class:

```cpp
static const BopomofoKeyboardLayout* CustomLayout() {
    static BopomofoKeyboardLayout layout(customMapping, "Custom Layout Name");
    return &layout;
}
```

#### 3. Handle Special Rules (Optional)
If your layout requires special disambiguation rules, add logic in `syllableFromKeySequence()`:

```cpp
// Example: Special handling for custom layout
if (this == CustomLayout()) {
    // Add custom heuristics here
    // e.g., automatic corrections, special key combinations
}
```

#### 4. Register Layout
Add the layout to the available options in the application preferences and input method controller.

#### 5. Testing
Create comprehensive tests covering:
- Key sequence to syllable conversion
- Syllable to key sequence conversion  
- Special rule validation
- Edge cases and invalid inputs

## Design of Language Model (McBopomofoLM)

The language model manages text conversion, user customization, and phrase suggestions.

### Architecture

#### McBopomofoLM Class
- **Inheritance**: Extends `Formosa::Gramambular2::LanguageModel`
- **Purpose**: Central hub for all language processing
- **Integration**: Combines multiple data sources and processing layers

### Data Processing Pipeline

When processing unigrams (single-character/phrase entries):

1. **Original Unigrams**: Retrieve from primary language model
2. **Exclusion Filtering**: Remove user-excluded phrases
3. **Phrase Replacement**: Apply user-defined replacements
4. **External Conversion**: Transform via external converter (if enabled)
5. **Deduplication**: Remove duplicate entries
6. **Return Results**: Provide final candidate list

### Key Components

#### Primary Language Model
- **ParselessLM**: Main language model for character/phrase data
- **Unigram-based**: Uses single-token probability model
- **File-based**: Loads from bundled data files

#### User Customization
- **UserPhrasesLM**: User-defined custom phrases
- **Exclusion List**: User-blocked phrases
- **Replacement Map**: User-defined phrase substitutions
- **Associated Phrases**: Context-based phrase suggestions

#### External Processing
- **Macro Converter**: Handles text macros and shortcuts
- **External Converter**: Traditional/Simplified Chinese character conversion (OpenCC-based)
- **Runtime Configuration**: Enable/disable features dynamically

### File Management
- **User Data Folder**: Configurable location for user files
- **Template System**: Automatic creation of empty user files
- **Atomic Updates**: Safe file writing and reloading

## Algorithm of Gramambular2

Gramambular2 is the core segmentation and input method library using statistical models.

### Theoretical Foundation

#### Hidden Markov Model (HMM)
- **Observations**: Input characters or Bopomofo syllables
- **Hidden States**: Possible character/phrase groupings
- **Goal**: Find most likely segmentation given input sequence

#### Naive Bayes Classification
- **Approach**: Simplified probabilistic classification
- **Assumptions**: Independence between features
- **Efficiency**: Fast computation suitable for real-time input

### Core Algorithm

#### Segmentation Process
1. **Input Sequence**: Receive series of observations (syllables/characters)
2. **State Generation**: Generate possible hidden states (character combinations)
3. **Probability Calculation**: Compute likelihood using unigram model
4. **Path Selection**: Choose most probable segmentation path
5. **Output Generation**: Return most likely character sequence

#### Language Model Integration
- **Unigram Model**: Simple single-token probability model
- **Frequency-based**: Probabilities derived from corpus frequency
- **Extensible**: Support for custom language models

### Implementation Details

#### Reading Grid
- **Purpose**: Manages candidate generation and selection
- **Structure**: Grid of possible readings and conversions
- **Optimization**: Efficient storage and retrieval of candidates

#### Language Model Interface
- **Abstract Base**: `LanguageModel` interface for pluggable models
- **Standard Methods**: `hasUnigrams()`, `getUnigrams()` for data access
- **Extensibility**: Support for custom language model implementations

### Performance Characteristics
- **Real-time**: Optimized for interactive input method use
- **Memory Efficient**: Minimal memory footprint
- **Scalable**: Handles large dictionaries efficiently
- **Fast Lookup**: Quick candidate generation and ranking

### Use Cases
1. **Input Method**: Convert Bopomofo sequences to Chinese characters
2. **Text Segmentation**: Break Chinese text into meaningful units
3. **Candidate Ranking**: Order possible conversions by probability
4. **Context Awareness**: Consider surrounding text for better suggestions

## Development Guidelines

### Code Organization
- **Swift**: Use for UI, state management, and application logic
- **C++**: Use for performance-critical algorithms and data processing
- **Objective-C++**: Use for bridging between Swift and C++

### Testing
McBopomofo employs a comprehensive testing strategy with both C++ and Swift test suites:

#### C++ Engine Tests
Located in `Source/Engine/`, these tests validate core algorithms and data structures:

- **Unit Tests**: Individual component testing using Google Test framework
- **Test Files**:
  - `MandarinTest.cpp`: Bopomofo syllable and keyboard layout tests
  - `McBopomofoLMTest.cpp`: Language model functionality tests
  - `ParselessLMTest.cpp`: Language model parsing and data structure tests
  - `UTF8HelperTest.cpp`: UTF-8 string processing tests
  - `UserPhrasesLMTest.cpp`: User-defined phrase management tests
  - `PhraseReplacementMapTest.cpp`: Phrase replacement logic tests
  - `KeyValueBlobReaderTest.cpp`: Data file reading tests
  - `MemoryMappedFileTest.cpp`: Memory-mapped file operations tests
  - `AssociatedPhrasesV2Test.cpp`: Associated phrase suggestion tests
  - `UserOverrideModelTest.cpp`: User override functionality tests
- **Coverage**: Core engine components, data structures, algorithms
- **Build**: Integrated with CMake build system

#### Swift Application Tests
Located in `McBopomofoTests/`, these tests validate application logic and UI integration:

- **Test Framework**: XCTest framework for Swift testing
- **Test Files**:
  - `KeyHandlerBopomofoTests.swift`: Input processing and key handling tests
  - `KeyHandlerPlainBopomofoTests.swift`: Plain Bopomofo input tests
  - `PreferencesTests.swift`: User preferences and configuration tests
  - `DictionaryServiceTests.swift`: Dictionary lookup service tests
  - `ServiceProviderTests.swift`: Input method service provider tests
  - `AssociatedPhrasesTests.swift`: Associated phrase functionality tests
  - `InputMacroTests.swift`: Text macro processing tests
  - `VersionUpdateTests.swift`: Version management and update tests
- **Integration**: Tests complete input workflows and state management
- **UI Testing**: Validates user interface components and interactions

#### Mixed Language Tests
- **UTF8HelperTest.mm**: Objective-C++ test bridging Swift and C++ components
- **Bridging Header**: `McBopomofoTests-Bridging-Header.h` enables Swift-C++ interop in tests

#### Testing Approach
- **Isolated Testing**: C++ tests focus on algorithmic correctness
- **Integration Testing**: Swift tests validate complete user workflows
- **Cross-Language Testing**: Objective-C++ tests ensure proper bridging
- **Continuous Validation**: Both test suites run during development cycles

### Debugging
- **State Inspection**: Monitor InputState transitions
- **Language Model**: Verify unigram processing pipeline
- **Syllable Processing**: Check Bopomofo key handling

### Performance Considerations
- **Memory Management**: Careful handling of large language model data
- **Real-time Constraints**: Input method must be responsive
- **Battery Usage**: Optimize for minimal system impact

## Braille Module (BopomofoBraille Package)

McBopomofo includes comprehensive support for Taiwanese Braille conversion through the BopomofoBraille Swift package.

### Overview

The Braille module provides bidirectional conversion between Traditional Chinese Bopomofo text and Taiwanese Braille, enabling accessibility features for visually impaired users.

### Core Functionality

#### BopomofoBrailleConverter Class
- **Primary Interface**: `BopomofoBrailleConverter` provides static methods for conversion
- **Bidirectional**: Supports both Bopomofo-to-Braille and Braille-to-Bopomofo conversion
- **Standard Compliance**: Implements Taiwanese Braille standards

#### Conversion Methods

```swift
// Convert Bopomofo to Braille
let bpmf = "ㄓㄨㄥㄨㄣˊㄓㄨˋㄧㄣ"
let braille = BopomofoBrailleConverter.convert(bopomofo: bpmf)

// Convert Braille back to Bopomofo
let originalBpmf = BopomofoBrailleConverter.convert(braille: braille)
```

### Conversion Features

#### Token Processing
The converter handles multiple token types:

- **BopomofoSyllable Tokens**: Direct phonetic symbol conversion
- **Digit Tokens**: Numeric character handling with appropriate Braille representations
- **Letter Tokens**: Latin alphabet support for mixed content
- **Punctuation Tokens**: 
  - Full-width punctuation (Chinese punctuation marks)
  - Half-width punctuation (ASCII punctuation)

#### State Machine Architecture
The converter uses a finite state machine with states:
- **Initial**: Starting state for new conversion
- **BPMF**: Processing Bopomofo syllables
- **Digits**: Handling numeric sequences
- **Letters**: Processing Latin characters

#### Special Character Handling
- **Whitespace Preservation**: Maintains tabs and newlines in original positions
- **Mixed Content**: Seamlessly handles text with Chinese, numbers, and Latin characters
- **Punctuation Context**: Appropriate Braille representations based on surrounding content

### Integration with Input Method

#### Service Menu Integration
The Braille converter integrates with macOS system services:
- **Keyboard Shortcut**: Users can invoke Braille conversion via Ctrl+Enter
- **Context Menu**: Available in system Services menu for selected text
- **Real-time Conversion**: On-demand conversion during input sessions

#### User Workflow
1. User selects Bopomofo text in any application
2. Invokes Braille conversion through Services menu or keyboard shortcut
3. System replaces selected text with Braille equivalent
4. Conversion is reversible for editing purposes

### Technical Implementation

#### Package Structure
```
BopomofoBraille/
├── Sources/BopomofoBraille/
│   ├── Converter.swift          # Main conversion engine
│   └── Tokens/                  # Token type definitions
│       ├── BopomofoSyllable.swift
│       ├── Digit.swift
│       ├── Letter.swift
│       ├── FullWidthPunctuation.swift
│       └── HalfWidthPunctuation.swift
└── Tests/                       # Comprehensive test suite
```

#### Error Handling
- **Graceful Degradation**: Invalid input characters are preserved or marked
- **Partial Conversion**: Successfully converts portions of mixed valid/invalid content
- **State Recovery**: Robust error recovery maintains conversion state integrity

### Accessibility Impact

#### User Benefits
- **Screen Reader Compatibility**: Braille output works with assistive technologies
- **Tactile Reading**: Physical Braille displays can render the converted content
- **Educational Support**: Helps users learn both Bopomofo and Braille systems
- **Professional Use**: Enables document preparation for Braille publication

#### Standards Compliance
- **Taiwanese Braille**: Follows official Taiwanese Braille encoding standards
- **Unicode Support**: Proper handling of Unicode Braille patterns (U+2800-U+28FF)
- **Bidirectional Integrity**: Round-trip conversion maintains content fidelity

## System Service Menu Integration

McBopomofo integrates with macOS system services to provide text processing capabilities beyond the input method itself. These services are accessible through the macOS Services menu and context menus throughout the system.

### ServiceProvider Architecture

#### Core Service Provider
The `ServiceProvider` class implements the system service functionality:
- **Text Processing**: Handles selected text from any macOS application
- **Reading Extraction**: Intelligently extracts phonetic readings from Chinese text
- **User Phrase Integration**: Seamlessly integrates with McBopomofo's user phrase system

#### Service Delegate Protocol
The service provider communicates with the input method through:
- **Insertion Requests**: Request to insert generated readings into input buffer
- **Commit Operations**: Trigger text commitment to client applications
- **State Management**: Coordinate service operations with input method state

### Available Services

#### Add User Phrase Service
**Function**: `addUserPhrase(_:userData:error:)`
**Purpose**: Creates user-defined phrases from selected text in any application

**Workflow**:
1. User selects Chinese text in any macOS application (Safari, TextEdit, etc.)
2. Right-clicks and selects "Add to McBopomofo User Phrases" from Services menu
3. System extracts the text and attempts to determine phonetic reading
4. ServiceProvider processes the text:
   - Converts Simplified Chinese to Traditional Chinese (if needed)
   - Uses language model to find phonetic readings
   - Handles multi-character phrases by finding optimal segmentation
5. Automatically opens user phrases file for verification/editing
6. New phrase becomes immediately available in input method

#### Reading Extraction Algorithm
The service uses sophisticated text analysis:

```swift
// Greedy longest-match algorithm
func extractReading(from firstWord: String) -> String {
    var matches: [String] = []
    var matchFrom = firstWord.startIndex
    
    while matchFrom < firstWord.endIndex {
        // Try progressively shorter substrings until match found
        let substring = firstWord.suffix(from: matchFrom)
        for drop in 0..<substring.count {
            let candidate = String(substring.dropLast(drop))
            if let reading = findPhoneticReading(candidate) {
                matches.append(reading)
                // Advance past matched portion
                break
            }
        }
    }
    
    return matches.joined(separator: "-")
}
```

#### Braille Conversion Service
**Integration**: Works with BopomofoBraille package
**Activation**: Ctrl+Enter keyboard shortcut or Services menu
**Function**: Converts selected Bopomofo text to Taiwanese Braille

**Features**:
- **Real-time Preview**: Shows conversion results immediately
- **Bidirectional**: Can convert both Bopomofo→Braille and Braille→Bopomofo
- **Mixed Content**: Handles text with Chinese, numbers, punctuation, and Latin characters
- **Accessibility**: Integrates with macOS accessibility features

### Service Menu Registration

#### NSService Integration
McBopomofo registers with macOS through:
- **Info.plist Configuration**: Declares available services and their handlers
- **Service Provider Binding**: Links service calls to appropriate methods
- **Menu Text Localization**: Provides localized service names for different languages

#### Service Availability
Services appear in:
- **Application Services Menu**: [AppName] → Services → McBopomofo services
- **Context Menus**: Right-click on selected text shows available services
- **Keyboard Shortcuts**: System-wide keyboard shortcuts for quick access

### User Experience

#### Discovery
- **Contextual Appearance**: Services only appear when relevant (text is selected)
- **Visual Feedback**: Clear menu labels indicate what each service does
- **Keyboard Shortcuts**: Power users can memorize shortcuts for frequent operations

#### Integration Benefits
- **System-wide Availability**: Works in any macOS application that supports text selection
- **Workflow Enhancement**: Allows building custom phrases without switching to input method
- **Accessibility Support**: Braille conversion works with screen readers and assistive technologies

### Technical Implementation

#### Pasteboard Handling
- **Text Extraction**: Safely reads selected text from system pasteboard
- **Format Preservation**: Maintains text formatting when possible
- **Error Handling**: Gracefully handles empty selections or unsupported content

#### Cross-Process Communication
- **Service Invocation**: Handles service calls from external applications
- **State Synchronization**: Coordinates with active input method instance
- **Resource Management**: Efficiently manages memory and system resources

#### Security and Privacy
- **Sandboxing Compliance**: Operates within macOS sandboxing restrictions
- **User Consent**: Respects user privacy settings for text processing
- **Data Handling**: Processes text locally without external transmission